\section{Introduction}
This project is about the development of the back-end of the bootstrap compiler for the Meta-Casanova 3 language.
The back-end is responsible for generating an executable after receiving the type-checked information from the front-end.

Compilers are complex programs that have to operate on a wide range of inputs.
Since compilers have such a large input-space, the chance of a bug hiding somewhere is substantial. 
But for al their complexity, compilers also have to be bug-free since every program can only be as bug-free as its compiler.

Abstractions can help in this regard.
The limits of which were observed when implementing the compiler for the Casanova language in F\#.
The compiler was 0000 lines long, and became unmaintainable.
After a rewrite in MC it was 000 lines[Maggiore].

The primary reason for this was the lack of higher-order type operators.
This made abstractions such as monad-transformers impossible, hampering modularity and resulted in a lot of boilerplate code.

In this document, we will walk through the backend and examine the various parts and their design decisions.
In this way, this document aims to be useful to the future developers of the MC compiler.

\subsection{Research question}

\textit{How to transform typechecked Meta-Casanova(MC) into executable code?}

Where the transformation must satisfy these requirements:
\begin{enumerate}
    \item The backend must in no case produce an incorrect program.
    \item The executable must be able to inter-operate with .NET.
    \item The generated code must run on all the platforms .NET runs on.
\end{enumerate}

An additional soft requirement was that the performance of the generated program should be as high as possible.

The first requirement exists because the compiler must be reliable.
Any program can at most be as reliable as the compiler used to generate it.

\label{whydotnet}
The second requirement existed because of the need for a large library and inter-operability with Unity game engine.
This is because the main area of research of the organization is game-related.

In order to answer the research question, seven subquestions were formulated.

\begin{enumerate}
    \item In what language should the code generator produce its output?
    \item What should the interface be between the front-end and the back-end?
    \item What should the intermediate representation of the functions be?
    \item How does the intermediate representation map to the output language?
    \item How to make sure that the generated names comply with the output language?
    \item How to validate the code-generator?
    \item How to validate the test programs?
\end{enumerate}

These subquestions will be answered in their respective subsections in section 3.


\subsection{Overview}

To illustrate how the different parts of the back-end relate to each other, here is a diagram of the dataflow through the backend.

\includegraphics[width=\columnwidth]{overview}

As you can see, the front-end interface contains the IR and goes through the validator.
From there, depending on the compiler flags, it either goes to the interpreter or the codegen.
In case it goes to the interpreter, the program is directly executed.
In case it goed to the codegen, it is translated to the output language.
To translate all the identifiers, the mangler is needed.
The debugger is optionally embedded in the executable, depending on compiler flags.

\subsection{Organization}
--- todo: describe organization ---

