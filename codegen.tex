\subsection{Code generator} \label{codegen}
The fourth research question gets at the heart of the back-end.

\textit{How does the intermediate representation map to the output language?}

The codegen is in many ways the heart of the back end, as it is responsible for generating the C\# code.

\subsubsection{Functions}
Every function was implemented as a closure.
In C\# this means a class with a public field for each function argument and a \verb|_run| function that takes the last argument and executes the function.

\begin{CS}[escapeinside=\#\#]
class #\textit{<function name>}# {
    #\textit{<function arguments>}#
    public #\textit{<return type>}# 
    _run(#\textit{<last argument>}#) {
        {
            #\textit{<rule 1 implementation>}#
            return #\textit{<local>}#;
        }
      skip1:
        {
            #\textit{<rule 2 implementation>}#
            return #\textit{<local>}#;
        }
      skip2:
        #\vdots#
        {
            #\textit{<rule n implementation>}#
            return #\textit{<local>}#;
        }
      skip#\textit{n}#:
        throw new #\textit{<exception>}#;
    }
};
\end{CS}

The \verb|_run| function opens a local scope followed by a goto-label for each rule in the function.
This allows rules to easily fail by jumping ahead to the label.
More on rules ahead in subsection \textit{rules}.

\subsubsection{Data declarations}
Data declarations are implemented with inheritance.
The declared type is represented by an empty baseclass and all the constructors inherit from it.

This is a pretty straight-forward transformation.

\begin{MC}
Data string -> "," -> int -> string * int

Data "Left"  -> string -> string | float
Data "Right" -> float  -> string | float
\end{MC}

The above MC code transforms into the following C\# code.

\begin{CS}
class _star {};
class _comma { string _arg0; int _arg1;}

class _pipe {};
class _Left :_pipe {string _arg0;};
class _Right:_pipe {float  _arg0;};
\end{CS}

The types \verb|_star| and \verb|_pipe| can now be easily be deconstructed.
When a premis deconstructs a datatype, it asserts that a type is constructed by a specific constructor.
This is done by simply casting the base-class to a subclass, and checking if the cast succeeded.
If the cast failed, the rule does not match and the rule is skipped.

\subsubsection{Rules}\label{codegen_rules}

Each rule defines its own name for each input argument.
These names do not have to be the same, for example:

\begin{MC}
    Func "evenOrOdd" -> int -> string
    
    a%2 = 1
    -----------------
    evenOrOdd a -> "odd!"

    b%2 = 0
    ------------------
    evenOrOdd b -> "even!"
\end{MC}

Of course, by the time the code has arived by the codegen, it would already have been normalized.
So the rules actually look more like this:

\begin{MC}[escapeinside=\#\#]
    (%) -> _tmp0         #\textit{(closure)}#
    _tmp0 a -> _tmp1     #\textit{(application)}#
    2 -> _tmp2           #\textit{(literal)}#
    _tmp1 _tmp2 -> _tmp3 #\textit{(call)}#
    0 -> _tmp4           #\textit{(literal)}#
    tmp4 = tmp0          #\textit{(conditional)}#
    "even" -> _tmp5      #\textit{(literal)}#
    --------------------
    evenOrOdd a -> _tmp5
\end{MC}

\begin{MC}[escapeinside=\#\#]
    (%) -> _tmp0         #\textit{(closure)}#
    _tmp0 a -> _tmp1     #\textit{(application)}#
    2 -> _tmp2           #\textit{(literal)}#
    _tmp1 _tmp2 -> _tmp3 #\textit{(call)}#
    1 -> _tmp4           #\textit{(literal)}#
    tmp4 = tmp0          #\textit{(conditional)}#
    "odd" -> _tmp5       #\textit{(literal)}#
    --------------------
    evenOrOdd a -> _tmp5
\end{MC}

The first job of the rule is to translate the input arguments to their name and return the output.

\begin{CS}
    {
        var a = _arg0; 
        ...
        return _tmp5;
    }
    _skip0:
    {
        var b = _arg0;
        ...
        return _tmp5;
    }
    _skip1:
\end{CS}

Then each instruction is generated.

\begin{CS}
    {
        var a = _arg0; 
        // closure
        var _tmp0 = new _plus(); 
        // application
        var _tmp1 = add;
        _tmp1._arg0 = a;
        // literal
        var _tmp2 = 2;
        // call
        var _tmp3 = _tmp1.run(_tmp2);
        // literal     
        var _tmp4 = 1;
        // conditional
        if(!(_tmp3=_tmp4)){goto _skip0;}
        // literal
        "odd!" -> _tmp5;
        return _tmp5;
    }
    _skip0:
    {
        var b = _arg0;
        ...
        return _tmp5;
    }
    _skip1:
\end{CS}

See the figure 1 on the next page for an overview of instruction generation.

\subsubsection{Evolution}
Before using inheritance, the plan was to use overlapping memory like C unions. 
Using \verb|System.|\verb|Runtime.|\verb|InteropServices|, it was possible to set the specific offset of struct members.
While this was multiplatform and worked well, it only worked with structs.
This was a major limitation, because structs can only hold value-types.
And the only value types are integers, floats, booleans and other structs.

\input{codegentable} % double width and page-breaking
