\section{The front-end interface}
The front-end interface is the interface between the front-end and the back-end.
It contains all the information the backend needs.
Primarily the lambda and function defenitions, and the data declarations.

\begin{code}
type Interface = {
  datas      : List<Id*Data>
  funcs      : List<Id*List<rule>>
  lambdas    : List<LambdaId*rule>
  main       : rule
  assemblies : List<string> 
  flags      : CompilerFlags
}
\end{code}

The design principles for this interface were simplicity and minimalism.
There should be as few ways as possible to represent the same program.
This makes testing easier and minimizes bugs that appear only in certain representations of the same program.

The reason that datas, funcs and lambdas are defined as a list of key-value pairs instead of as a Map, is that the keys are not guaranteed to be unique.
Since MC allows polymorphic types, one indentifier may be defined multiple times: once for each type.
There is no performance penalty, as no lookups by identifier are performed.

\subsection{Data declarations}
The data declarations are grouped with the identifier of 

\begin{code}
datas : List<Id*Data>
\end{code}

Where \verb|Data| is simply a list of input types and output types.

\begin{code}
type Data = {
  args       : List<Type>
  outputType : Type
}
\end{code}

Where \verb|Type| represents a monomorphic MC type.

%\begin{code}
%type Type 
%  = DotNetType      of TypeId
%  | McType          of TypeId
%  | TypeApplication of Type*List<Type>
%  | Arrow           of Type*Type
%\end{code}

To illustrate, let's define a tuple an a union in MC.

\begin{code}
Data int -> "," -> string -> int * string
Data "fst" -> int    -> int | string
Data "snd" -> string -> int | string
\end{code}

This will appear as the following list in the interface:

\begin{tabular}{lll}
    \textbf{identifier} & \textbf{arguments} & \textbf{type}\\
    \verb:",":   & \verb:int:; \verb:string: & \verb:int * string: \\
    \verb:"fst": & \verb:int:                & \verb:int | string: \\
    \verb:"snd": & \verb:string:             & \verb:int | string: \\
\end{tabular}


\subsection{Rule containers}

Function and lambda definitions, aswell as the main function contain rules.

\begin{code}
  funcs   : List<Id*List<rule>>
  lambdas : List<LambdaId*rule>
  main    : rule
\end{code}

Functions in MC can contain multiple rules that implement them.

The entry-point of the program is defined by a single rule, here called \verb|main|.
It is not a full function since full functions can have multiple rules.
This was done to make the entry-point as simple as possible.

\subsection{Rules}

Rules rules rules.

\begin{code}
type rule = {
  premises    : List<premise*linenr>
  input       : List<local_id>
  output      : local_id
  typemap     : Map<local_id,Type>
  declaration : Position
  definition  : Position
}
\end{code}

At the heart of the rule is the list of premises.
These premises are a simple and orthogonal instructions in SSA form.

--- design of premises here ---

\subsection{Metadata}

All the symbols in the descriptions are provided with monomorphic types by the front-end.
Functions with generic types are made concrete by the front-end.

Rules are represented wi

The AST was developed in co-operation with the front-end developer.
