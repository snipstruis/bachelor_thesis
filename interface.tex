\section{The front-end interface}
The front-end interface is the interface between the front-end and the back-end.
All the inputs for the back-end are in this datastructure.

Primarily the lambda and function defenitions, and the data declarations.

\begin{code}
type Interface = {
  datas      : List<Id*Data>
  funcs      : List<Id*List<rule>>
  lambdas    : List<LambdaId*rule>
  main       : rule
  assemblies : List<string> 
  flags      : CompilerFlags
}
\end{code}

The design principles for this interface were simplicity and minimalism.
There should be as few ways as possible to represent the same program.
This makes testing easier and minimizes bugs that appear only in certain representations of the same program.

All the symbols in the descriptions are provided with monomorphic types by the front-end.
Functions with generic types are made concrete by the front-end.

The reason that datas, funcs and lambdas are defined as a list of key-value pairs instead of as a Map, is that the keys are not guaranteed to be unique.
Since MC allows polymorphic types, one indentifier may be defined multiple times: once for each type.
There is no performance penalty, as no lookups by identifier are performed.

\subsection{Data declarations}
The data declarations are grouped with the identifier of ---

\begin{code}
datas : List<Id*Data>
\end{code}

Where \verb|Data| is simply a list of input types and output types.

\begin{code}
type Data = {
  args       : List<Type>
  outputType : Type
}
\end{code}

Where \verb|Type| represents a monomorphic MC type.

%\begin{code}
%type Type 
%  = DotNetType      of TypeId
%  | McType          of TypeId
%  | TypeApplication of Type*List<Type>
%  | Arrow           of Type*Type
%\end{code}

To illustrate, let's define a tuple an a union in MC.

\begin{code}
Data int -> "," -> string -> int * string
Data "fst" -> int    -> int | string
Data "snd" -> string -> int | string
\end{code}

This will appear as the following list in the interface:

\begin{tabular}{lll}
    \textbf{identifier} & \textbf{arguments} & \textbf{type}\\
    \verb:",":   & \verb:int:; \verb:string: & \verb:int * string: \\
    \verb:"fst": & \verb:int:                & \verb:int | string: \\
    \verb:"snd": & \verb:string:             & \verb:int | string: \\
\end{tabular}


\subsection{Rule containers}

Function and lambda definitions, aswell as the main function contain rules.

\begin{code}
  funcs   : List<Id*List<rule>>
  lambdas : List<LambdaId*rule>
  main    : rule
\end{code}

Functions in MC can contain multiple rules that implement them.

The entry-point of the program is defined by a single rule, here called \verb|main|.
It is not a full function since full functions can have multiple rules.
This was done to make the entry-point as simple as possible.

\subsection{Rules}

Rules rules rules.

\begin{code}
type rule = {
  premises    : List<premise*linenr>
  input       : List<local_id>
  output      : local_id
  typemap     : Map<local_id,Type>
  declaration : Position
  definition  : Position
}
\end{code}

input and output.
premises contain instructions, explained in next section.
typemap.
debug info.

\subsection{Validator}
The first versions of the backend had no working front-end to test with.
So the early testing was done by writing the interface datastructure by hand.
Because that was error-prone, I implemented an automatic checker for the interface to check the invariants.

The validator asserts the following:
\begin{enumeration}
\item Each local identifier is defined only once.
\item Each local identifier has a type in the typemap.
\item Each function has at least one rule.
\end{enumeration}

The validator was initially only for testing hand-written interfaces,
but it proved to be very good in catching errors that slipped through the front-end.
The validator now always checks the interface before it is handed to the codegen.

