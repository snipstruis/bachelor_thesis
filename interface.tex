\subsection{The front-end interface}
The second research question is about the specification of the front-end interface.

\textit{What should the interface between the front-end and the back-end be?}

The front-end interface contains all the input for the backend.
This makes testing very easy, as the rest of the backend only relies on its input.

\subsubsection{Interface}

\begin{code}
type Interface = {
  datas      : List<Id*Data>
  funcs      : List<Id*List<rule>>
  lambdas    : List<LambdaId*rule>
  main       : rule
  flags      : CompilerFlags
  assemblies : List<string> 
}
\end{code}

As you can see, the interface contains the data declarations, function definitions, lambda definitions and a main function.

The design principles for this interface were simplicity and minimalism.
There should be as few ways as possible to represent the same program.
This makes testing easier and minimizes bugs that appear only in certain representations of the same program.

All the symbols in the descriptions are provided with monomorphic types by the front-end.
Functions with generic types are made concrete by the front-end.

The reason that datas, funcs and lambdas are defined as a list of key-value pairs instead of as a Map, is that the keys are not guaranteed to be unique.
Since MC allows polymorphic types, one indentifier may be defined multiple times: once for each type.
There is no performance penalty for the back-end, as no lookups by identifier are performed.

\subsubsection{Data declarations}
The data declarations are grouped with the identifier of the constructor.

\begin{code}
datas : List<Id*Data>
\end{code}

Where \verb|Data| is simply a list of input types and output types.

\begin{code}
type Data = {
  args       : List<Type>
  outputType : Type
}
\end{code}

Where \verb|Type| represents a monomorphic MC type.

%\begin{code}
%type Type 
%  = DotNetType      of TypeId
%  | McType          of TypeId
%  | TypeApplication of Type*List<Type>
%  | Arrow           of Type*Type
%\end{code}

To illustrate, let's define a tuple an a union in MC.

\begin{code}
Data int -> "," -> string -> Tupple<int string>
Data "fst" -> int    -> Union<int string>
Data "snd" -> string -> Union<int string>
\end{code}

This will appear as the following list in the interface:

{\footnotesize
\begin{tabular}{lll}
    \textbf{\normalsize identifier} & \textbf{\normalsize arguments} & \textbf{\normalsize type}\\
    \verb:",":   & \verb:int:; \verb:string: & \verb:Tuple<int string>: \\
    \verb:"fst": & \verb:int:                & \verb:Union<int string>: \\
    \verb:"snd": & \verb:string:             & \verb:Union<int string>: \\
\end{tabular}
}


\subsubsection{Rule containers}

Function and lambda definitions, as well as the main function contain rules.

\begin{code}
  funcs   : List<Id*List<rule>>
  lambdas : List<LambdaId*rule>
  main    : rule
\end{code}

Functions in MC can contain multiple rules that implement them.

The entry point of the program is defined by a single rule, here called \verb|main|.
It is not a full function since full functions can have multiple rules.
This was done to make the entry-point as simple as possible.

\subsubsection{Rules}

Functions are defined with of one or more \textit{rules}.
This is how they are represented in the interface.

\begin{code}
type rule = {
  premises    : List<premise*linenr>
  input       : List<local_id>
  output      : local_id
  typemap     : Map<local_id,Type>
  declaration : Position
  definition  : Position
}
\end{code}

The main component of rules are their premises.
They are the instructions that make up the rule.
The instruction set is described in section \ref{ir}.

The premise list also contains line numbers for each premisse.
This is debug information, that is used by the embedded debugger (section~\ref{debugger}).

Next are the inputs and output of the rule.
Input and outputs consist only of local identifiers.
This is because of \textit{normalization}.

In the case that a rule-input or output has an expression instead of a local identifer,
 the expression is assigned to a new local identifier and the local identifier is substituted.
More on normalization in section~\ref{normalization}.

The typemap contains a map from the local identifiers in a rule to their types.
This gives the back-end all the information that the typechecker has accumulated.

The last two members are \verb|declartion| and \verb|definition|.
These represent the position that the function was declared and the position that it was defined.
This information is used by the debugger.

\subsubsection{Validator}
The first versions of the backend had no working front-end to test with.
Early testing was done by writing the interface datastructure by hand.
Because that was error-prone, I implemented an automatic checker for the interface to check the invariants.

The validator asserts the following:
\begin{itemize}
\item Each local identifier is defined only once.
\item Each local identifier has a type in the typemap.
\item Each function has at least one rule.
\end{itemize}

The validator was initially only for validating hand-written interfaces,
but it proved to be very good in catching errors that slipped through the front-end.
The validator now always checks the interface before it is handed to the codegen.

