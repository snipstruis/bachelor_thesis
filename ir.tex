\subsection[Intermediate Representation]{Intermediate\\Representation}
Each rule contains a list of Premises.
These premises are normalized to one or more instructions.
These instructions are still valid MC.

The instruction set exists in two parts: the base instrucions and the .NET extentions.

\subsubsection{base instructions}
The instruction set was designed to minimize the number of representations of the same program.
This happens to coincide with a small orthogonal instruction set.

The instruction set is in \textit{static single assignment} (SSA) form.
This means the local identifiers are constant and can not be redefined.

Base instructions fall in one of two groups.
The first maps a global identifier to a local identifier.
This are the Literal and Closure instructions.
The second operates on local identifiers.
The Conditional, Deconstructor, Application and Call instructions belong to this group.

\begin{description}
\item[Literal] (\verb|42 -> x|) assigns a string-, boolean-, integer- or floating-point literal to a local identifier.
\item[Conditional] (\verb|x < y|) asserts that a comparison between local identifiers is true.
    If the assertion fails, the rule fails and the next rule in the function is attempted.
\item[Deconstructor] (\verb|lst -> x::xs|) disassembles a local identifier constructed by a data declaration.
\item[Closure] (\verb|(+) -> add|) assigns a closure of a global function to a local identifier.
    The closure can hold a function, lambda or data-constructor.
\item[Application] (\verb|add a -> inc|) applies a local identifier to a closure in another local identifier.
\item[Call] (\verb|inc b -> c|) applies a local identifier and calls the closure.
    All closures need to be called eventually to be usefull.
    The exception is data-constructors. 
    They do not have to be called as they insert their elements in the datastructure as they are applied.
\end{description}

\subsubsection{.NET extentions}
A seperate set of instructions are needed to inter-operate with .NET.
This is because unlike MC, .NET objects are mutable, and the functions can be overloaded on the number and types of arguments.

\begin{tabular}{ll}
    \textbf{instruction} & \textbf{MC example}\\
    call & \begin{lstlisting}
        System.DateTime d m y -> date
    \end{lstlisting}\\
    static call & \begin{lstlisting}
        System.DateTime d m y -> date
    \end{lstlisting}\\
    get & \begin{lstlisting}
        System.DateTime d m y -> date
    \end{lstlisting}\\
    static get & \begin{lstlisting}
        System.DateTime d m y -> date
    \end{lstlisting}\\
    set & \begin{lstlisting}
        System.DateTime d m y -> date
    \end{lstlisting}\\
    static set & \begin{lstlisting}
        System.DateTime d m y -> date
    \end{lstlisting}\\
\end{tabular}

\subsubsection{Evolution}
It was briefly considered to have the CIL code be the intermediate-representation, but it would mean over 100 instructions and the front-end would do most of the work.
It would also mean the front-end needed its own codegen to generate the CIL instructions.

Call did not used to apply an argument, but it caused inconsistencies.
There would be not difference in the type of the uncalled closure and the called closure.
This made type-analysis of the program nearly impossible, so it was decided that call also applies the last argument.

Application used to also take the position of the argument that was applied.
This was because the backend did not care in what order the closures were applied.
But since the MC language only allows for in-order closure application, the decision was made to make the position of the argument implicit.

